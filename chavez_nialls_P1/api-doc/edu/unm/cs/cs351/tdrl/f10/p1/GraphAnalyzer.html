<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_24) on Tue Aug 24 10:08:50 MDT 2010 -->
<TITLE>
GraphAnalyzer
</TITLE>

<META NAME="keywords" CONTENT="edu.unm.cs.cs351.tdrl.f10.p1.GraphAnalyzer interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GraphAnalyzer";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GraphAnalyzer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphStructureException.html" title="class in edu.unm.cs.cs351.tdrl.f10.p1"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../../index.html?edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphAnalyzer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.unm.cs.cs351.tdrl.f10.p1</FONT>
<BR>
Interface GraphAnalyzer&lt;T&gt;</H2>
<HR>
<DL>
<DT><PRE>public interface <B>GraphAnalyzer&lt;T&gt;</B></DL>
</PRE>

<P>
Interface for an object that analyzes basic graph structural statistics.
 Objects of this type provide a number of methods for calculating
 statistics about average graph topology, including shortest paths and
 connected components, diameter, degree distributions, etc.
 <p>
 <b>Caching</b> (optional).
 The intent is that objects of this type accept a <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><CODE>Graph</CODE></A>
 object in the constructor and then all operations are defined with
 respect to that <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><CODE>Graph</CODE></A>.  If this object is made immutable,
 and the <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><CODE>Graph</CODE></A> is not changed during the existence of this
 object, then the <code>GraphAnalyzer</code> can cache intermediate results.
 For example, a number of operations require essentially the same loop
 over the graph; the <code>GraphAnalyzer</code> can arrange to perform that
 loop only once and to cache the results of the computation.
 <p>
 Regardless of whether implementations of this interface support
 caching, the constructor
 for any concrete implementations MUST run in <i>O(1)</i> time and
 consume only <i>O(1)</i> space.  In
 particular, they MUST NOT pre-compute/pre-allocate any expensive values at
 construction time.  They MUST wait until
 requested via one of the methods defined in this interface.  This
 avoids potentially computing expensive results that will
 never be requested by the user.
 <p>
 The documentation of all methods in this interface assumes a
 directed graph, <i>G</i>, containing <i>V</i> nodes and <i>E</i>
 edges.  The notation <i>x^p</i> represents "<i>x</i> raised to
 the <i>p</i>th power", <em>not</em> "<code>x xor p</code>".  The
 notation <code>x_{ij}</code> should be read "<code>x</code> subscripted with
 <code>ij</code>". 
 <p>
 Note that none of the methods in this interface depend on the
 type of the <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><CODE>Graph</CODE></A>'s nodes -- <code>GraphAnalyzer</code> only
 cares about the <em>structure</em> of the graph, not its contents.
 However, objects of this type MUST be Java generics because they
 will be initialized with <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><CODE>Graph</CODE></A>s of some specific type.
 <p>
 <b>Efficiency</b> The runtime bounds given for a number of the
 operations in this interface are fairly loose.  It is certainly
 possible to carry out a number of these operations (such as
 all-pairs shortest paths and computation of strongly connected
 components) more efficiently than the values given here.  But the
 values given here are amenable to simple implementations.
 Ambitious designers are encouraged to find more efficient
 implementations of these operations.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.0</DD>
<DT><B>Author:</B></DT>
  <DD>terran</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#allPairsShortestPaths()">allPairsShortestPaths</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the all-pairs shortest paths distances between every
 pair of nodes in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#avgInDegree()">avgInDegree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the average INDEGREE for any node in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#avgOutDegree()">avgOutDegree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the average OUTDEGREE for any node in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#avgShortestPathDistance()">avgShortestPathDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the average distance between all reachable pairs of nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#countSCCs()">countSCCs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of strongly connected components (SCCs) in
 the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#diameter()">diameter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the diameter of the reachable portion of the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#inDegreeDistribution()">inDegreeDistribution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate the probability mass function (PMF) of the indegrees of
 nodes in this graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#maxInDegree()">maxInDegree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the maximum INDEGREE for any node in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#maxOutDegree()">maxOutDegree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the maximum OUTDEGREE for any node in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#maxSCCSize()">maxSCCSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the size of the largest strongly connected component (SCC)
 in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#minInDegree()">minInDegree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the minimum INDEGREE for any node in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#minOutDegree()">minOutDegree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the minimum OUTDEGREE for any node in the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#outDegreeDistribution()">outDegreeDistribution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate the probability mass function (PMF) of the outdegrees of
 nodes in this graph.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="allPairsShortestPaths()"><!-- --></A><H3>
allPairsShortestPaths</H3>
<PRE>
int[][] <B>allPairsShortestPaths</B>()</PRE>
<DL>
<DD>Compute the all-pairs shortest paths distances between every
 pair of nodes in the graph.  This uses an all-pairs shortest paths
 algorithm (such as Floyd-Warshall)
 to compute the shortest directed distance between every two nodes
 in the graph.  Note: this does <em>not</em> return the shortest
 paths themselves; it merely computes the distances that those paths
 require.
 <p>
 The returned matrix has one row and one column for every
 node in the graph.  The interpretation of this matrix is:
 <pre>
   dist[i][j]==d
 </pre>
 means that the shortest distance starting at node <code>i</code> and
 ending at node <code>j</code> is <code>d</code>.  (That is, nodes whose
 <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html#getNodeID(T)"><CODE>Graph.getNodeID(Object)</CODE></A> is <code>i</code> and <code>j</code>.)
 <p>
 The distance from node <code>i</code> to itself is <code>0</code> and
 if <code>j</code> is not reachable from <code>i</code> then
 <code>dist[i][j]==Integer.MAX_VALUE</code> (i.e., infinity).
 <p>
 If the graph is empty (contains no nodes or edges), then this
 returns a size-0 matrix.  That is, it returns essentially
 <code>new int[0]</code>.
 <p>
 This routine MUST run in <i>O(V^3)</i> time for a graph containing
 <i>V</i> nodes.  It SHOULD require only <i>O(V^2)</i> space.
 It MAY use more than <i>O(V^2)</i> space, but
 not more than <i>O(V^3)</i> space.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Inter-node distance matrix.</DL>
</DD>
</DL>
<HR>

<A NAME="avgShortestPathDistance()"><!-- --></A><H3>
avgShortestPathDistance</H3>
<PRE>
double <B>avgShortestPathDistance</B>()</PRE>
<DL>
<DD>Returns the average distance between all reachable pairs of nodes.
 That is, this examines all pairs of nodes, <code>i,j</code>, such that
 <code>dist[i][j]&lt;Integer.MAX_VALUE</code> and returns the average
 distance over those nodes.
 <p>
 An empty graph is defined to have an average distance of 0.
 <p>
 This method MUST run in time <i>O(V^2)</i> beyond that
 required by the <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#allPairsShortestPaths()"><CODE>allPairsShortestPaths()</CODE></A> method.  (That
 is, this method MAY execute <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#allPairsShortestPaths()"><CODE>allPairsShortestPaths()</CODE></A>
 and then spend up to <i>O(V^2)</i> time beyond that.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Average shortest-path distance</DL>
</DD>
</DL>
<HR>

<A NAME="countSCCs()"><!-- --></A><H3>
countSCCs</H3>
<PRE>
int <B>countSCCs</B>()</PRE>
<DL>
<DD>Returns the number of strongly connected components (SCCs) in
 the graph.  This locates the total number of strongly connected
 components in the graph, where a SCC (strongly connected component)
 is defined to be a set of mutually reachable nodes.  Note that
 a singleton node (a node with no outgoing or incoming edges) is,
 by definition, strongly connected, as it is automatically reachable
 from itself.
 <p>
 An empty graph is defined to have 0 strongly connected components.
 <p>
 This MUST run in time <i>O(V^3)</i> and require at most
 <i>O(V^2)</i> space.  However, most of that time/space is consumed
 in computing all-pairs shortest-paths (in the most straightforward
 implementation).
 This MUST require no more than <i>O(V^2)</i> time <em>beyond</em>
 that required by the all-pairs shortest paths execution, and
 comsume at most
 <i>O(V)</i> additional space.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Number of strongly connected components.</DL>
</DD>
</DL>
<HR>

<A NAME="maxSCCSize()"><!-- --></A><H3>
maxSCCSize</H3>
<PRE>
int <B>maxSCCSize</B>()</PRE>
<DL>
<DD>Return the size of the largest strongly connected component (SCC)
 in the graph.  While <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#countSCCs()"><CODE>countSCCs()</CODE></A> finds <em>how many</em>
 SCCs there are, this identifies the largest such component and
 returns the size (number of nodes) of that component.
 <p>
 An empty graph is defined to have 0 SSCs, the largest of which
 is size 0.
 <p>
 This MUST run in time no more than <i>O(S)</i> beyond that required
 by <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html#countSCCs()"><CODE>countSCCs()</CODE></A>, for a graph containing <i>S</i> SCCs.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Number of nodes in the largest SCC in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="diameter()"><!-- --></A><H3>
diameter</H3>
<PRE>
int <B>diameter</B>()</PRE>
<DL>
<DD>Computes the diameter of the reachable portion of the graph.
 This method finds the maximum distance between any pair of nodes
 that are reachable (i.e., whose distance is not infinite).  That
 is, it computes
 <pre>
 dmax=max_{i,j in V} ( d_{ij} )
 subject to:
   d_{ij}&lt;Integer.MAX_VALUE
 </pre>
 <p>
 An empty graph is defined to have a diameter of 0.
 <p>
 This MUST run in time <i>O(V^3)</i>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Diameter of reachable portion of the graph</DL>
</DD>
</DL>
<HR>

<A NAME="maxInDegree()"><!-- --></A><H3>
maxInDegree</H3>
<PRE>
int <B>maxInDegree</B>()</PRE>
<DL>
<DD>Computes the maximum INDEGREE for any node in the graph.  This
 method finds the node with the maximum number of edges entering
 it, and returns that number of edges.
 <p>
 An empty graph is defined to have a max indegree of 0.
 <p>
 This method MUST run in <i>O(V+E)</i> time for a graph with <i>V</i>
 nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Maximum indegree over all nodes in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="minInDegree()"><!-- --></A><H3>
minInDegree</H3>
<PRE>
int <B>minInDegree</B>()</PRE>
<DL>
<DD>Computes the minimum INDEGREE for any node in the graph.  This
 method finds the node with the minimum number of edges entering
 it, and returns that number of edges.   Note that a node with
 no parents has an INDEGREE of 0, although a node with a
 self-edge has an INDEGREE of 1.
 <p>
 An empty graph is defined to have a min indegree of 0.
 <p>
 This method MUST run in <i>O(V+E)</i> time for a graph with <i>V</i>
 nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Minimum indegree over all nodes in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="avgInDegree()"><!-- --></A><H3>
avgInDegree</H3>
<PRE>
double <B>avgInDegree</B>()</PRE>
<DL>
<DD>Computes the average INDEGREE for any node in the graph.  This
 method computes the average number of parents of any node in
 the graph.  This can be as low as 0 for a completely disconnected
 graph (no node has any parents) or as high as <i>V</i> for a
 completely connected graph (i.e., a clique -- a graph in which every
 node is a parent of every other node).
 <p>
 An empty graph is defined to have an average indegree of 0.0.
 <p>
 This method MUST run in <i>O(V+E)</i> time for a graph with <i>V</i>
 nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Average indegree over all nodes in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="inDegreeDistribution()"><!-- --></A><H3>
inDegreeDistribution</H3>
<PRE>
double[] <B>inDegreeDistribution</B>()</PRE>
<DL>
<DD>Calculate the probability mass function (PMF) of the indegrees of
 nodes in this graph. This method computes the frequency of occurrence
 of each possible indegree over this graph. For a graph of <i>n</i>
 nodes, the result is an array of <i>n+1</i> values.  The <i>j</i> entry
 of the result gives the <em>frequency</em> (not count) of nodes that
 have an indegree of <i>j</i>.  Note that the minimum possible indegree
 for any node is <code>0</code>, represented by <code>result[0]</code>, and the
 maximum is <code>n</code>, represented by <code>result[n]</code>.
 <p>
 Note that this method is responsible for allocating space for the result
 array.  It MUST NOT allocate more (or less) space than necessary.
 <p>
 If the graph is empty, this returns an empty distribution.  That is,
 a distribution containing 0 elements.
 <p>
 This method MUST run in <i>O(V+E)</i> time for a graph with <i>V</i> nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Frequency distribution (i.e., PMF) of indegrees over all nodes in
 the target graph.</DL>
</DD>
</DL>
<HR>

<A NAME="maxOutDegree()"><!-- --></A><H3>
maxOutDegree</H3>
<PRE>
int <B>maxOutDegree</B>()</PRE>
<DL>
<DD>Computes the maximum OUTDEGREE for any node in the graph.  This
 method finds the node with the maximum number of edges leaving
 it, and returns that number of edges.
 <p>
 An empty graph is defined to have a max outdegree of 0.
 <p>
 This method MUST run in <i>O(V)</i> time for a graph with <i>V</i>
 nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Maximum outdegree over all nodes in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="minOutDegree()"><!-- --></A><H3>
minOutDegree</H3>
<PRE>
int <B>minOutDegree</B>()</PRE>
<DL>
<DD>Computes the minimum OUTDEGREE for any node in the graph.  This
 method finds the node with the smallest number of edges leaving
 it, and returns that number of edges.  Note that a node with
 no neighbors has an OUTDEGREE of 0, although a node with a
 self-edge has an OUTDEGREE of 1.
 <p>
 An empty graph is defined to have a min outdegree of 0.
 <p>
 This method MUST run in <i>O(V)</i> time for a graph with <i>V</i>
 nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Minimum outdegree over all nodes in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="avgOutDegree()"><!-- --></A><H3>
avgOutDegree</H3>
<PRE>
double <B>avgOutDegree</B>()</PRE>
<DL>
<DD>Computes the average OUTDEGREE for any node in the graph.  This
 method computes the average number of neighbors of any node in
 the graph.  This can be as low as 0 for a completely disconnected
 graph (no node has any neighbors) or as high as <i>V</i> for a
 completely connected graph (i.e., a clique -- a graph in which every
 node is a neighbor of every other node).
 <p>
 An empty graph is defined to have an average outdegree of 0.0.
 <p>
 This method MUST run in <i>O(V)</i> time for a graph with <i>V</i>
 nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Average outdegree over all nodes in the graph.</DL>
</DD>
</DL>
<HR>

<A NAME="outDegreeDistribution()"><!-- --></A><H3>
outDegreeDistribution</H3>
<PRE>
double[] <B>outDegreeDistribution</B>()</PRE>
<DL>
<DD>Calculate the probability mass function (PMF) of the outdegrees of
 nodes in this graph. This method computes the frequency of occurrence
 of each possible outdegree over this graph. For a graph of <i>n</i>
 nodes, the result is an array of <i>n+1</i> values.  The <i>j</i> entry
 of the result gives the <em>frequency</em> (not count) of nodes that
 have an outdegree of <i>j</i>.  Note that the minimum possible outdegree
 for any node is <code>0</code>, represented by <code>result[0]</code>, and the
 maximum is <code>n</code>, represented by <code>result[n]</code>.
 <p>
 Note that this method is responsible for allocating space for the result
 array.  It MUST NOT allocate more (or less) space than necessary.
 <p>
 If the graph is empty, this returns an empty distribution.  That is,
 a distribution containing 0 elements.
 <p>
 This method MUST run in <i>O(V)</i> time for a graph with <i>V</i> nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Frequency distribution (i.e., PMF) over outdegrees for all nodes in
 the target graph.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GraphAnalyzer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/Graph.html" title="interface in edu.unm.cs.cs351.tdrl.f10.p1"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../../edu/unm/cs/cs351/tdrl/f10/p1/GraphStructureException.html" title="class in edu.unm.cs.cs351.tdrl.f10.p1"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../../index.html?edu/unm/cs/cs351/tdrl/f10/p1/GraphAnalyzer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphAnalyzer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
